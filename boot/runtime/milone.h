// Runtime code for C programs generated by the milone-lang compiler.

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// null-terminated string
struct String {
  char* str;
  int len;
};

// structure for memory management. poor implementation. thread unsafe.
struct MemoryChunk {
  // depth of region where this chunk is allocated.
  int level;
  // size of allocated memory. for debugging.
  int size;
  // the allocated memory. need to free after leaving the region.
  void *ptr;
  // parent chunk or null.
  struct MemoryChunk *next;
};

static struct MemoryChunk *s_heap;
static int s_heap_level;
static int s_heap_len;
static int s_heap_size;

void milone_enter_region(void) {
  // fprintf(stderr, "debug: enter_region level=%d len=%d size=%d\n", s_heap_level + 1, s_heap_len, s_heap_size);

  s_heap_level++;
}

void milone_leave_region(void) {
  // fprintf(stderr, "debug: leave_region level=%d len=%d size=%d\n", s_heap_level, s_heap_len, s_heap_size);

  assert(s_heap_level > 0);
  s_heap_level--;

  // Free chunks allocated in the region.
  struct MemoryChunk *chunk = s_heap;
  while (chunk && chunk->level > s_heap_level) {
    free(chunk->ptr);
    struct MemoryChunk *next = chunk->next;
    s_heap_len--;
    s_heap_size -= chunk->size;

    free(chunk);
    chunk = next;
  }
  s_heap = chunk;

  // fprintf(stderr, "debug: free len=%d sizes=%d\n", s_heap_len, s_heap_size);
}

void *milone_mem_alloc(int count, size_t size) {
  void *ptr = calloc(count, size);

  struct MemoryChunk *next = s_heap;
  struct MemoryChunk *chunk = (struct MemoryChunk *)calloc(1, sizeof(struct MemoryChunk));
  chunk->level = s_heap_level;
  chunk->size = count * size;
  chunk->ptr = ptr;
  chunk->next = next;
  s_heap = chunk;

  s_heap_len++;
  s_heap_size += chunk->size;

  return ptr;
}

int int_cmp(int l, int r) {
  if (l == r) return 0;
  if (l < r) return -1;
  return 1;
}

int int_clamp(int x, int l, int r) {
  if (x < l) return l;
  if (x > r) return r;
  return x;
}

int str_cmp(struct String left, struct String right) {
  int min_len = int_clamp(left.len, 0, right.len);
  return memcmp(left.str, right.str, min_len + 1);
}

/// Create a string from a slice of native C string.
struct String str_of_raw_parts(char const* p, int len) {
  if (len <= 0) {
    if (len < 0) {
      fprintf(stderr, "FATAL: Negative string length (%d).\n", len);
      abort();
    }

    return (struct String){.str = "", .len = 0};
  }

  char* str = (char*)milone_mem_alloc(len + 1, sizeof(char));
  memcpy(str, p, len * sizeof(char));
  str[len] = '\0';
  return (struct String){.str = str, .len = len};
}

struct String str_add(struct String left, struct String right) {
  if (left.len == 0 || right.len == 0) {
    return right.len == 0 ? left : right;
  }
  int len = left.len + right.len;
  char* str = (char*)milone_mem_alloc(len + 1, sizeof(char));
  memcpy(str, left.str, left.len);
  memcpy(str + left.len, right.str, right.len);
  assert(str[len] == '\0');
  return (struct String){.str = str, .len = len};
}

struct String str_get_slice(int l, int r, struct String s) {
  l = int_clamp(l, 0, s.len);
  r = int_clamp(r + 1, l, s.len);
  int len = r - l;
  char* str;
  if (r == s.len) {
    str = s.str + l;
  } else {
    str = (char*)milone_mem_alloc(len + 1, sizeof(char));
    memcpy(str, s.str + l, len);
  }
  assert(str[len] == '\0');
  return (struct String){.str = str, .len = len};
}

int str_to_int(struct String s) {
  return atoi(s.str);
}

struct String str_of_int(int value) {
  char* str = (char *)milone_mem_alloc(20, sizeof(char));
  sprintf(str, "%d", value);
  return (struct String){.str = str, .len = strlen(str)};
}

uint32_t str_to_uint(struct String s) {
  char* endptr = s.str + s.len;
  uint32_t n = strtoul(s.str, &endptr, 10);
  if ((*endptr != '\0' && !isspace(*endptr)) || errno == ERANGE) {
    fprintf(stderr, "FATAL: Failed to convert a string to uint.\n");
    abort();
  }
  return n;
}

struct String str_of_uint(uint32_t value) {
  char buf[20] = {};
  int len = sprintf(buf, "%u", value);
  return str_of_raw_parts(buf, len);
}

struct String str_of_char(char value) {
  char* str = (char *)milone_mem_alloc(2, sizeof(char));
  str[0] = value;
  return (struct String){.str = str, .len = strlen(str)};
}

void milone_assert(int cond, int y, int x) {
  if (!cond) {
    fprintf(stderr, "Assertion failed at (%d, %d)\n", y + 1, x + 1);
    exit(1);
  }
}

int file_exists(struct String file_name) {
  int ok = 0;

  FILE *fp = fopen(file_name.str, "r");
  if (fp) {
    ok = 1;
    fclose(fp);
  }

  return ok;
}

struct String file_read_all_text(struct String file_name) {
  FILE *fp = fopen(file_name.str, "r");
  if (!fp) {
    fprintf(stderr, "File '%s' not found.", file_name.str);
    abort();
  }

  fseek(fp, 0, SEEK_END);
  long size = ftell(fp);
  if (size < 0) {
    fclose(fp);
    fprintf(stderr, "%s", "Couldn't retrieve the file size.");
    abort();
  }
  fseek(fp, 0, SEEK_SET);

  char *content = (char *)milone_mem_alloc((size_t)size + 1, sizeof(char));
  size_t read_size = fread(content, 1, (size_t)size, fp);
  if (read_size != (size_t)size) {
    fclose(fp);
    fprintf(stderr, "%s", "Couldn't retrieve the file contents");
    abort();
  }

  fclose(fp);
  return (struct String){.str = content, .len = size};
}

int file_write_all_text(struct String file_name, struct String content) {
  FILE *fp = fopen(file_name.str, "w");
  if (!fp) {
    fprintf(stderr, "File '%s' not found.", file_name.str);
    abort();
  }

  fprintf(fp, "%s", content.str);

  fclose(fp);
  return 0;
}

long milone_get_time_millis() {
#ifdef __timespec_defined // C11 feature
  struct timespec t;
  timespec_get(&t, TIME_UTC);
  return t.tv_sec * 1000L + t.tv_nsec / (1000L * 1000L);
#else
  time_t t;
  time(&t);
  return t * 1000L;
#endif
}

struct Profiler {
  long epoch;
  long heap_size;
};

void *milone_profile_init(int _unit) {
  struct Profiler* p = (struct Profiler *)milone_mem_alloc(1, sizeof(struct Profiler));
  p->epoch = milone_get_time_millis();
  p->heap_size = s_heap_size;
  return p;
}

int milone_profile_log(struct String msg, void *profiler) {
  struct Profiler *p = (struct Profiler *)profiler;

  long t = milone_get_time_millis();
  long s = p->epoch;

  long millis = t - s;
  if (millis < 0) {
    millis = 0;
  }

  long sec = millis / 1000;
  millis %= 1000;

  long bytes = s_heap_size - p->heap_size;
  if (bytes < 0) {
    bytes = 0;
  }

  long kilo = bytes / 1000;
  bytes %= 1000;

  long mega = kilo / 1000;
  kilo %= 1000;

  fprintf(stderr, "profile: time=%4d.%03d mem=%5d,%03d,%03d\n%s\n", (int)sec, (int)millis, (int)mega, (int)kilo, (int)bytes, msg.str);

  p->epoch = t;
  p->heap_size = s_heap_size;
  return 0; // can't be void due to restriction of __nativeFun
}

static int s_argc;
static char **s_argv;

int arg_count(int _unit) {
  return s_argc;
}

struct String arg_get(int index) {
  if (!(0 <= index && index < s_argc)) {
    abort();
  }

  char *str = s_argv[index];
  int len = strlen(str);
  return (struct String){.str = str, .len = len};
}

int main(int argc, char** argv) {
  s_argc = argc - 1;
  s_argv = argv + 1;

  int milone_main();
  return milone_main();
}

#define main milone_main
