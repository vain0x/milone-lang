/// `build.ninja` file generation.
module rec MiloneCli.NinjaFileGen

open Std.Path
open MiloneShared.Util

module S = Std.StdString

[<RequireQualifiedAccess; NoEquality; NoComparison>]
type NinjaProjectParams =
  {
    ProjectName: string

    /// Filename (basename) to be generated.
    OutputFile: string
    /// Absolute path, the output file is copied to after built.
    CopyOpt: string option

    CFlags: string list
    /// Files to be compiled. (fst: C file, snd: obj file)
    CFiles: (string * string) list
    /// `link` ($CC) or `"archive"` ($AR)
    LinkRule: string
    LinkFlags: string list
    /// Files specified in link command arguments.
    LinkInputs: string list
  }

[<RequireQualifiedAccess; NoEquality; NoComparison>]
type NinjaFileParams =
  {
    /// Absolute path to `target`
    TargetDir: string
    /// Absolute path of MILONE_HOME.
    MiloneHome: string

    /// C compiler command (e.g. `gcc`.)
    CcCmd: string
    /// Archiver command (e.g. `ar`.)
    ArCmd: string
    /// Copy command line for the platform (e.g. `cp`, `cmd /c copy`.)
    CpCmd: string
    /// Extension of object files (`.o` on Linux, `.obj` on Windows.)
    ObjExt: string
  }

let private escape (s: string) =
  if s |> S.contains ":" then S.replace ":" "$:" s else s

let generateNinjaFile (a: NinjaFileParams) (projects: NinjaProjectParams list) : string =
  assert (a.ObjExt = ".o" || a.ObjExt = ".obj")

  let miloneHome = a.MiloneHome
  let targetDir = a.TargetDir

  let cFile name = Pathname.join targetDir name

  let objFile name =
    Pathname.join targetDir (Pathname.stem name + a.ObjExt)

  let rules =
    """# Generated by milone command.

builddir = ${TARGET_DIR}

include_flag = -I${MILONE_HOME}/src/libmilonert
milone_h = ${MILONE_HOME}/src/libmilonert/milone.h
milone_c = ${MILONE_HOME}/src/libmilonert/milone.c
milone_o = ${TARGET_DIR}/milone${OBJ_EXT}
milone_platform_c = ${MILONE_HOME}/src/libmilonert/milone_platform.c
milone_platform_o = ${TARGET_DIR}/milone_platform${OBJ_EXT}
defined_macro = -DNDEBUG -DUNICODE -D_UNICODE -DWIN32 -D_WIN32

rule cc
  description = cc $in
  command = ${CC} $c_flags $in -o $out

rule link
  description = link $out
  command = ${CC} $link_flags $in -o $out

rule archive
  description = archive $out
  command = ${AR} r $out $in

rule copy
  description = copy $in $out
  command = ${CP} $in $out

build $milone_o: cc $milone_c | $milone_h
  c_flags = $include_flag $defined_macro -O2 -std=c11 -c

build $milone_platform_o: cc $milone_platform_c | $milone_h
  c_flags = $include_flag $defined_macro -O2 -std=c11 -c
"""

  let rules =
    rules
    |> S.replace "${MILONE_HOME}" miloneHome
    |> S.replace "${TARGET_DIR}" targetDir
    |> S.replace "${OBJ_EXT}" a.ObjExt
    |> S.replace "${CC}" (escape a.CcCmd)
    |> S.replace "${AR}" (escape a.ArCmd)
    |> S.replace "${CP}" (escape a.CpCmd)

  let acc = [ rules ]

  // Each projects:
  //
  //    # <ProjectName>
  //    my_c_flags = ...
  //
  //    <Foreach C files>
  //      build <file.o>: cc <file.c> | $milone_h
  //        c_flags = $my_c_flags
  //
  //    build <output.exe>: link <file.o>... <input.o>... $milone_o $milone_platform_o
  //      link_flags = ...
  //
  //    <If copy specified>
  //      build <copy>: copy <output.exe>
  let acc =
    projects
    |> List.fold
      (fun acc (p: NinjaProjectParams) ->
        assert (p.LinkRule = "link" || p.LinkRule = "archive")

        let projectName = p.ProjectName
        let prefix = projectName + "__"
        let cFlagsVar = prefix + "c_flags"

        let acc = acc |> cons "\n# Project: " |> cons projectName |> cons "\n\n"

        let acc =
          acc
          |> cons cFlagsVar
          |> cons " = "
          |> cons (S.concat " " p.CFlags)
          |> cons "\n\n"

        let acc =
          p.CFiles
          |> List.fold
            (fun acc (c, o) ->
              acc
              |> cons "build "
              |> cons (escape (objFile o))
              |> cons ": cc "
              |> cons (escape (cFile c))
              |> cons " | $milone_h\n  c_flags = $"
              |> cons cFlagsVar
              |> cons "\n")
            acc

        let linkInputs =
          List.collect
            id
            [ p.CFiles |> List.map (fun (_, o) -> escape (objFile o))
              p.LinkInputs |> List.map escape
              [ "$milone_o"; "$milone_platform_o" ] ]

        let acc =
          acc
          |> cons "build "
          |> cons (escape p.OutputFile)
          |> cons ": "
          |> cons p.LinkRule
          |> cons " "
          |> cons (S.concat " " linkInputs)
          |> cons "\n  link_flags = "
          |> cons (S.concat " " p.LinkFlags)
          |> cons "\n"

        let acc =
          match p.CopyOpt with
          | Some copyFile ->
            acc
            |> cons "\nbuild "
            |> cons (escape copyFile)
            |> cons ": copy "
            |> cons (escape p.OutputFile)
            |> cons "\n"
          | None -> acc

        acc)
      acc

  // Final:
  //
  //  # Default
  //  build all: phony <output.exe>... <copy>...
  //
  //  default all
  let acc =
    let outputFiles =
      projects |> List.map (fun (p: NinjaProjectParams) -> escape p.OutputFile)

    let copyFiles =
      projects
      |> List.choose (fun (p: NinjaProjectParams) -> p.CopyOpt)
      |> List.map escape

    let allInputs = List.append outputFiles copyFiles |> S.concat " "

    acc
    |> cons "\n# Default\n\nbuild all: phony "
    |> cons allInputs
    |> cons "\ndefault all\n"

  acc |> List.rev |> S.concat ""
