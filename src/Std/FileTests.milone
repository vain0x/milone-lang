open Std.ByteVector
open Std.File
open Std.StdTesting
open Std.Vector

__nativeDecl "#include <assert.h>"

let private write () =
  __nativeStmt
    """
      FILE *fp = fopen("output.ignored.txt", "wb+");
      assert(fp != NULL);
    """

  let stream = StreamExt.unsafeWrap (__nativeExpr "fp")

  let ok, stream = stream |> Stream.writeString "Hello, world!\n"
  assert ok
  let ok, stream = stream |> Stream.writeString "Good bye!\n"
  assert ok

  let fp = __dispose(StreamExt.unsafeUnwrap stream)
  __nativeStmt "fclose(fp);"

let private read () =
  __nativeStmt
    """
      FILE *fp = fopen("output.ignored.txt", "rb+");
      assert(fp != NULL);
    """

  let stream = StreamExt.unsafeWrap (__nativeExpr "fp")

  let contents, stream = Stream.readToEnd (Vector.empty ()) stream
  let length, contents = Vector.length contents
  let s, contents = ByteVector.sliceToString 0 length contents
  assert (shouldEqual id "Hello, world!\nGood bye!\n" s)
  Vector.dispose contents

  let fp = __dispose(StreamExt.unsafeUnwrap stream)
  __nativeStmt "fclose(fp);"

let private readLineCase () =
  __nativeStmt
    """
      FILE *fp = fopen("output.ignored.txt", "rb+");
      assert(fp != NULL);
    """

  let stream = StreamExt.unsafeWrap (__nativeExpr "fp")

  let buf = Vector.alloc 1024
  let ok, buf, stream = Stream.readLine buf stream
  assert ok
  let length, buf = Vector.length buf
  let s, buf = ByteVector.sliceToString 0 length buf
  assert (shouldEqual id "Hello, world!\n" s)

  let ok, buf, stream = Stream.readLine buf stream
  assert ok
  let length2, buf = Vector.length buf
  let s, buf = ByteVector.sliceToString length length2 buf
  assert (shouldEqual id "Good bye!\n" s)

  let ok, buf, stream = Stream.readLine buf stream
  assert (not ok) // EOF.

  Vector.dispose buf

  let fp = __dispose(StreamExt.unsafeUnwrap stream)
  __nativeStmt "fclose(fp);"

let testFile () =
  write ()
  read ()
  readLineCase ()
  __nativeStmt """remove("output.ignored.txt");"""
