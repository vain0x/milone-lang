open Std.ByteVector
open Std.File
open Std.StdError
open Std.StdTesting
open Std.Vector

__nativeDecl "#include <assert.h>"

let private writeCase () =
  __nativeStmt
    """
      FILE *fp = fopen("output.ignored.txt", "wb+");
      assert(fp != NULL);
    """

  let file = FileExt.unsafeWrap (__nativeExpr "fp")

  let ok, file = file |> File.writeString "Hello, world!\n"
  assert ok
  let ok, file = file |> File.writeString "Good bye!\n"
  assert ok
  File.close file

let private readCase () =
  let file =
    match File.openRead "output.ignored.txt" with
    | Some it -> it
    | None ->
      failwith "Not found"
      File.stdin () // HACK: failwith "" can't be File

  let contents, file = File.readToEnd (Vector.empty ()) file
  let length, contents = Vector.length contents
  let s, contents = ByteVector.sliceToString 0 length contents
  assert (shouldEqual id "Hello, world!\nGood bye!\n" s)
  Vector.dispose contents
  File.close file

let private readLineCase () =
  let file =
    match File.openRead "output.ignored.txt" with
    | Some it -> it
    | None ->
      failwith "Not found"
      File.stdin () // HACK: failwith "" can't be File

  let buf = Vector.alloc 1024
  let ok, buf, file = File.readLine buf file
  assert ok
  let length, buf = Vector.length buf
  let s, buf = ByteVector.sliceToString 0 length buf
  assert (shouldEqual id "Hello, world!\n" s)

  let ok, buf, file = File.readLine buf file
  assert ok
  let length2, buf = Vector.length buf
  let s, buf = ByteVector.sliceToString length length2 buf
  assert (shouldEqual id "Good bye!\n" s)

  let ok, buf, file = File.readLine buf file
  assert (not ok) // EOF.

  Vector.dispose buf
  File.close file

let testFile () =
  writeCase ()
  readCase ()
  readLineCase ()
  __nativeStmt """remove("output.ignored.txt");"""
