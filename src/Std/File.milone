// Provides file system API.
//
// Currently functionality is designed similar to C standard library.
open Std.ByteVector
open Std.StdError
open Std.Vector

// For strlen.
__nativeDecl "#include <string.h>"

let private toCStr (s: string) : __constptr<char> = __nativeFun ("str_to_c_str", s)

/// `FILE *`
type private FilePtr = nativeptr<__nativeType<FILE>>

/// Represents a connection to an opened file.
type File = private File of __linear<FilePtr>

/// Unsafely retrieves a `FILE *` ptr, which must not outlive `File` value.
let private unsafeDup (file: File) : FilePtr * File =
  let (File fp) = file
  let fp = __dispose fp
  fp, File(__acquire fp)

module File =
  /// Gets the file abstraction of standard input.
  let stdin () : File =
    File(__acquire (__nativeExpr "stdin"))

  /// Gets the file abstraction of standard output.
  let stdout () : File =
    File(__acquire (__nativeExpr "stdout"))

  /// Gets the file abstraction of standard error.
  let stderr () : File =
    File(__acquire (__nativeExpr "stderr"))

  /// Opens a regular file for reading.
  let openRead (pathname: string) : File option =
    let fp: FilePtr =
      __nativeFun ("fopen", toCStr pathname, toCStr "r")

    if __nativeExpr ("{0} != NULL", fp) then
      Some(File(__acquire fp))
    else
      None

  /// Closes the file.
  ///
  /// The underlying file descriptor is closed.
  /// Remark: Closing stdin/stdout/stderr is noop. It's required to close such file due to the linearity check.
  let close (file: File) : unit =
    let (File fp) = file
    let fp = __dispose fp

    __nativeStmt (
      """
        FILE *fp = {0};
        if (fp != stdin && fp != stdout && fp != stderr) fclose(fp);
      """,
      fp
    )

  /// Reads a chunk from the file to append the buffer.
  ///
  /// Returns size of read data. Maybe less than capacity.
  let readBlock (dest: Vector<byte>) (input: File) : int * Vector<byte> * File =
    let fp, input = unsafeDup input
    let destPtr, destLength, destCapacity, dest = VectorExt.unsafeDup dest

    __nativeStmt (
      "int len = (int)fread(&{1}[{2}], 1, (size_t){3}, {0});",
      fp,
      destPtr,
      destLength,
      destCapacity - destLength
    )

    let len: int = __nativeExpr "len"
    len, dest, input

  /// Reads a block of bytes equal to the specified size from the file to append the buffer.
  ///
  /// This function blocks to wait until the buffer is fill (unless the underlying file is asynchronous).
  /// Returns whether the size of read data equals to the specified size.
  let readExact (dest: Vector<byte>) (size: int) (input: File) : bool * Vector<byte> * File =
    assert (size >= 0)

    let fp, input = unsafeDup input

    let destPtr, destLength, destCapacity, dest =
      VectorExt.unsafeDup (VectorExt.reserve size dest)

    __nativeStmt ("bool ok = fread(&{1}[{2}], (size_t){3}, 1, {0}) == 1;", fp, destPtr, destLength, size)

    let ok: bool = __nativeExpr "ok"
    ok, dest, input

  /// Reads all contents from the file to append the buffer.
  let readToEnd (dest: Vector<byte>) (input: File) : Vector<byte> * File =
    let fp, input = unsafeDup input

    let rec go dest input =
      let dest = VectorExt.reserve 4000 dest
      let destPtr, destLength, destCapacity, dest = VectorExt.unsafeDup dest

      __nativeStmt (
        "int len = (int)fread(&{1}[{2}], 1, (size_t){3}, {0});",
        fp,
        destPtr,
        destLength,
        destCapacity - destLength
      )

      let len: int = __nativeExpr "len"

      if len = 0 then
        dest, input
      else
        let dest =
          VectorExt.unsafeSetLength (int destLength + len) dest

        go dest input

    go dest input

  /// Reads a line from the file to append the buffer.
  ///
  /// Input buffer must have capacity enough to contain a line.
  /// This function doesn't reserve.
  ///
  /// Returns false if empty or error.
  ///
  /// If the file read a newline character, it was also appended to the buffer.
  let readLine (buf: Vector<byte>) (file: File) : bool * Vector<byte> * File =
    let bufPtr, length, capacity, buf = VectorExt.unsafeDup buf
    let fp, file = unsafeDup file

    assert (length < capacity)

    __nativeStmt (
      """
        char *p = fgets(&{0}[{1}], {2}, {3});
        uint32_t size = p != NULL ? (uint32_t)strlen(p) : 0;
      """,
      bufPtr,
      length,
      unativeint (capacity - length),
      fp
    )

    let size: uint = __nativeExpr "size"

    let buf =
      VectorExt.unsafeSetLength (int (length + size)) buf

    size <> 0u, buf, file

  /// Unsafely writes a block of bytes to the file.
  ///
  /// This function blocks to wait until all data are written (unless the underlying file is asynchronous).
  let unsafeWriteExactFromRawParts (ptr: __constptr<byte>) (len: int) (output: File) : bool * File =
    let fp, output = unsafeDup output
    assert (len >= 1)

    __nativeStmt ("bool ok = fwrite({1}, {2}, 1, {0}) == 1;", fp, ptr, uint len)

    let ok: bool = __nativeExpr "ok"
    ok, output

  /// Writes a string to the file.
  let writeString (s: string) (output: File) : bool * File =
    let fp, output = unsafeDup output

    if s.Length <> 0 then
      let ptr: __constptr<char> = __nativeExpr ("{0}.str", s)

      let ok, output =
        unsafeWriteExactFromRawParts (__nativeCast ptr) s.Length output

      if ok then
        __nativeStmt ("fflush({0});", fp)

      ok, output
    else
      true, output

/// Features rarely used or unsafe.
module FileExt =
  /// `FILE *`
  type FilePtr = nativeptr<__nativeType<FILE>>

  /// Unsafely wraps a `FILE *` ptr in an abstraction.
  let unsafeWrap (fp: __linear<FilePtr>) : File =
    File(__acquire (__nativeCast (__dispose fp)))

  /// Unsafely unwraps an abstraction and returns a `File *` ptr.
  let unsafeUnwrap (file: File) : __linear<FilePtr> =
    let (File fp) = file
    __acquire (__nativeCast (__dispose fp))
