# 設計

## 実装機能

型

- int
- float
- char
- string
- 関数 (クロージャ)
- option
- list
- array
- 判別共用体 (再帰、多相)
- タプル
- レコード (再帰、多相)
- 型エイリアス

導出

- (=)
- hash
- toJson
- fromJson

関数

- 多相
- 再帰
- クロージャ
- 部分適用

モジュール

など

## プロジェクト

規約

- 単一のプロジェクトのソースファイルは単一のディレクトリに配置しなければいけない。
- 単一のプロジェクトは単一の名前空間に属するトップレベル module 宣言を持たなければいけない。
    - 名前空間の名称や階層構造はディレクトリと無関係。

構成ファイル

- プロジェクトをビルドするときは、単一のファイルを指定する。これをエントリーポイントと呼ぶ。
- エントリーポイントのトップレベル宣言を `module X.A` とする。
- プロジェクトに含まれるファイルが `open X.B` を含むなら、プロジェクトのディレクトリにあるファイル `B.fs` がプロジェクトに含まれる。
- プロジェクトに含まれるファイルが `open Y` や `open Y.C` (Y≠X) を含むなら、外部プロジェクト Y を参照する。

ビルド

- プロジェクトはライブラリとしてのみビルドされる。
- メタデータファイル、C言語のヘッダファイル、C言語のソースファイルを生成する。
- メタデータには以下が含まれる。
    - プロジェクト UUID
    - 参照するプロジェクトのリスト
    - open 宣言
    - 名前ツリー
    - 関数・型の定義 (KIR)

## 字句解析

- ソースファイルごとに、ソースコードをトークンのリストに分解する。
- 各トークンにファイル番号と位置情報 (列, 行) を付与する。

## 構文解析

ソースファイルごとに、ロスレス構文木を構築する。

参考: [rust-analyzer/syntax.md](https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md)

文法解釈は v1 と同様、綺麗にフォーマットされているものだけ対象とする。

## AST

AST ノードは構文木のノードのラッパーとして定義する。

```fs
type ALetExpr =
    | ALetExpr
        of SNode
```

構文木を解析して子要素を探索する関数を定義する。

```fs
type ALetExprView =
    {
        KwOpt: SToken option
        PatOpt: APat option
        EqOpt: SToken option
        BodyOpt: AExpr option
        InOpt: SToken option
        NextOpt: AExpr option
        Syntax: SNode
    }

let aLetExprView (ALetExpr syntax): ALetExprView
```

## プロジェクト解決

プロジェクトが必要とするファイルをロードし、参照している外部プロジェクトのメタデータと、プロジェクト内のソースファイルの AST を列挙する。

- ソースファイルがロードされるたび
    - 構文解析する
    - AST から open 宣言を探索する
    - 参照している外部プロジェクトのメタデータや、他のソースファイルをロードする
- エントリーポイントをロードする
- ソースファイルの AST をトポロジカル順序で並べて、ソースファイルIDを振る。
- 外部プロジェクトのメタデータにソースファイルIDを振り直し、適切に置換する。

## 名前解決

名前や静的なメンバーアクセスを解決する。

名前ツリー

- 名前空間/モジュール名/型名/メンバ名、のような階層構造をなすトライツリー
- 名前IDから名前パスへのマップ
- ノードは名前、名前ID、定義位置を持つ
- 名前ID = (ソースファイルID, 適当な連番)
- 名前パス = 名前IDのリスト (ツリー上のパス)

手順

- 参照している外部プロジェクトのメタデータから名前ツリーを取り出してマージする。
- ソースファイルを順番に名前解決していく。
- AST からモジュール、モジュール直下の関数、型、型のメンバーを探索し、名前IDを振って名前ツリーに加える。
- AST を HIR に変換する。
    - 名前項やナビゲーション式を可能なかぎり、名前IDによる参照に置き換える。
    - モジュールや型のメンバーなどは名前ツリーから探索する。
    - 名前ツリーにない定義には新たに名前IDを割り振る。
    - 型情報は型変数を生成して埋める。

その他

- open 宣言は削除する。
- 内部モジュールは本体だけ取り出して削除する。
- 解決できないメンバーアクセスはそのままにする。

## 型推論

部分式の型を再構築する。

- ソースファイルを順番に型推論していく。

v1 と同様。

## 型正規化

- string, option, list に対応する判別共用体を生成する。
- 関数型、タプル、レコードを判別共用体に置き換える。
- タプルリテラル、with 式、レコードリテラルを判別共用体の生成に置き換える。

'a -> 'b

## パターンマッチ解決

- パターンマッチを条件分岐、単純パターンマッチ、関数呼び出しに変換する。

単純パターンマッチは以下のパターンからなる、束縛や分岐を持たない、パターンマッチのサブセット。

- 破棄パターン
- 定数パターン
- バリアントパターン (引数はすべて破棄パターン)
- タプルパターン (引数はすべて破棄パターン)

## CPS 変換

CPS 変換により HIR → KIR に変換する。

## 使用解析

KIR 上を走査して、各関数の自由変数を決定する。

## クロージャ変換

自由変数を持つ関数がクロージャを受け渡すようにする。

## 構造平坦化

KIR から型や関数の定義を取り出してトップレベルに移動する。

- 型・関数のリストで、関数の本体は型や関数の定義を含まない、というかたちになる。

## η 展開



## β 縮約

1箇所でのみ呼び出されている関数をインライン展開する。

## メタデータ生成

メタデータを生成する。

## 単相化

- 多相関数の単相な呼び出しを発見するたび、関数の単相インスタンスを生成して置き換える。
- 型変数がすべて単相型に束縛されている多相型がつく変数やフィールドを発見するたび、型の単相インスタンスを生成して置き換える。

## コード導出

(=) などの使用箇所を発見するたび、実装を生成して置き換える。

## 間接性挿入

- 型のデータサイズを計算し、一定以上なら参照型に分類する。

## CIR 生成

CIR を生成する。

## Cダンプ

CIR を文字列に変換する。

- StringBuilder を使う。

