module rec MiloneLspServer.Program

open MiloneLspServer.Json

module S = MiloneStd.StdString

let private unreachable (msg: string) =
  printfn "unreachable: %s" msg
  exit 1

let private unwrap (msg: string) (opt: 'T option): 'T  =
  match opt with
  | Some it -> it
  | None -> unreachable msg

let jsonParseString (s: string): JsonValue = __nativeFun ("json_parse_string", s)

let ioReadLine (): string option =
  let line: string = __nativeFun "io_read_line"
  if line = "" then None else Some line

let ioReadBlock (len: int): string = __nativeFun ("io_read_block", len)

let divide (sep: string) (s: string): string * string option =
  match S.findIndex sep s with
  | None -> s, None
  | Some i -> s.[0..i - 1], Some s.[i + sep.Length..s.Length - 1]

// -----------------------------------------------
// Db
// -----------------------------------------------

type DbValue =
  | DNull
  | DInt of int
  | DString of string

let dbOpen (fileName: string): unit =
  __nativeFun ("db_open", fileName)

let dbSelect (sql: string) (params: (string * DbValue) list): DbValue list list =
  __nativeFun ("db_select", sql, params)

let dbMutate (sql: string) (params: (string * DbValue) list): unit =
  __nativeFun ("db_mutate", sql, params)

let dbExec (sql: string): unit =
  __nativeFun ("db_exec", sql)

// -----------------------------------------------
// reader
// -----------------------------------------------

let startReader (): JsonValue option =
  let rec go lenOpt =
    let lineOpt =
      match ioReadLine () with
      | Some line -> Some (S.trimEnd line)
      | None -> None

    match lineOpt, lenOpt with
    | None, _ -> None

    | Some "", None ->
        printfn "error: missing Content-Length"
        exit 1

    | Some "", Some len ->
        let body = ioReadBlock len
        let msg = jsonParseString body
        Some msg

    | Some line, _ ->
        let key, valueOpt = divide ":" line

        let value =
          match valueOpt with
          | None ->
              printfn "error: invalid header line: '%s'" line
              exit 1

          | Some it -> it

        let key = S.trim key
        if key = "Content-Length" then
          go (Some(int value))
        else
          printfn "info: header ignored: '%s'." key
          go lenOpt

  go None

// -----------------------------------------------
// Writer
// -----------------------------------------------

let rec assocTryFind (name: string) (entries: (string * 'T) list): 'T option =
  match entries with
  | [] -> None
  | (key, value) :: _ when key = name -> Some value
  | _ :: entries -> assocTryFind name entries

let private asString (value: JsonValue): string option =
  match value with
  | JString value -> Some value
  | _ -> None

let private asInt (value: JsonValue): int option =
  match value with
  | JString value -> value |> float |> int |> Some
  | JNumber value -> value |> int |> Some
  | _ -> None

let private field1 (f: string) (value: JsonValue): JsonValue option =
  match value with
  | JObject entries -> assocTryFind f entries
  | _ -> None

let private field2 f1 f2 (value: JsonValue) =
  match value with
  | JObject entries ->
      match assocTryFind f1 entries, assocTryFind f2 entries with
      | Some f1, Some f2 -> Some (f1, f2)
      | _ -> None
  | _ -> None

let private field3 f1 f2 f3 (value: JsonValue) =
  match value with
  | JObject entries ->
      match
        assocTryFind f1 entries,
        assocTryFind f2 entries,
        assocTryFind f3 entries
      with
      | Some f1, Some f2, Some f3 -> Some (f1, f2, f3)
      | _ -> None
  | _ -> None

let private find2 f1 f2 value =
  value |> field1 f1 |> Option.bind (field1 f2)

let private find3 f1 f2 f3 value =
  value
  |> field1 f1
  |> Option.bind (field1 f2)
  |> Option.bind (field1 f3)

let private writeMsg (entries: (string * JsonValue) list): unit =
  let s = jsonToString (JObject entries)
  printfn "Content-Length: %d\r\n%s" (s.Length + 1) s

let private createInitializeResult () =
  jsonParseString
    """{
      "capabilities": {
        "textDocumentSync": {
            "openClose": true,
            "change": 1
        }
      },
      "serverInfo": {
          "name": "MiloneLspServer",
          "version": "0.2.0"
      }
    }"""

let private validate () =
  dbSelect """
    select uri, version, text from documents;
  """ [] |> List.fold (fun () row ->
    let uri, text =
      match row with
      | [ DString uri; _; DString text ] -> uri, text
      | _ -> unreachable "select documents"

    let pos row column =
      JObject [
        "line", JNumber (float (row + 1))
        "character", JNumber (float (column + 1))
      ]

    if text |> S.startsWith "module" |> not then
      writeMsg [
        "jsonrpc", JString "2.0"
        "method", JString "textDocument/publishDiagnostics"
        "params", JObject [
          "uri", JString uri
          "diagnostics", JArray [
            JObject [
              "range", JObject [
                "start", pos 0 0
                "end", pos 0 1
              ]
              "message", JString "Expected 'module'."
              "source", JString "MiloneLspServer"
            ]
          ]
        ]
      ]
  ) ()

let startWriter (msg: JsonValue): unit =
  let methodName =
    msg
    |> field1 "method"
    |> Option.bind asString
    |> Option.defaultWith (fun () -> unreachable ("no method: " + jsonToString msg))

  let getMsgId () =
    msg
    |> field1 "id"
    |> Option.defaultValue JNull

  match methodName with
  | "initialize" ->
      writeMsg [
        "jsonrpc", JString "2.0"
        "id", getMsgId ()
        "result", createInitializeResult ()
      ]

  | "initialized" -> ()

  | "shutdown" ->
      writeMsg [
        "jsonrpc", JString "2.0"
        "id", getMsgId ()
      ]

  | "exit" -> exit 0

  | "textDocument/didOpen" ->
      let uri, version, text =
        msg
        |> find2 "params" "textDocument"
        |> Option.bind (field3 "uri" "version" "text")
        |> unwrap "params.textDocument"

      let uri = asString uri |> unwrap "uri"
      let version = asInt version |> unwrap "version"
      let text = asString text |> unwrap "text"

      dbMutate """
        insert into documents(uri, version, text) values
          (:uri, :version, :text)
      """ [
        ":uri", DString uri
        ":version", DInt version
        ":text", DString text
      ]
      validate ()

  | "textDocument/didClose" ->
      let uri =
        msg
        |> find3 "params" "textDocument" "uri"
        |> Option.bind asString
        |> unwrap "uri"

      dbMutate """
        delete from documents
        where uri = :uri
      """ [
        ":uri", DString uri
      ]
      validate ()

  | "textDocument/didChange" ->
      let uri, version =
        msg
        |> find2 "params" "textDocument"
        |> Option.bind (field2 "uri" "version")
        |> unwrap "params.textDocument"

      let uri = uri |> asString |> unwrap "uri"
      let version = version |> asInt |> unwrap "version"

      let text =
        match msg |> find2 "params" "contentChanges" with
        | Some (JArray (JString text :: _)) -> text
        | _ -> unreachable "contentChanges"

      dbMutate """
        delete from documents
        where uri = :uri
      """ [
        ":uri", DString uri
      ]
      validate ()

  | _ ->
      writeMsg [
        "jsonrpc", JString "2.0"
        "id", getMsgId ()
        "error",
          JObject [
            "code", JNumber (-32601.0)
            "message", JString "Unimplemented method"
          ]
      ]

// -----------------------------------------------
// Entrypoint
// -----------------------------------------------

let concurrently (f1: unit -> int) (f2: unit -> int): int =
  __nativeFun ("concurrently", f1, f2)

let rec syncLoop () =
  let _ =
    inRegion (fun () ->
      match startReader () with
      | None -> ()
      | Some msg ->
          startWriter msg
      0
    )
  syncLoop ()

let main _ =
  let dbFile = "target/local.db"

  dbOpen dbFile

  dbExec """
    drop table if exists documents;
    create table documents(uri varchar(1024), version int, text text);
  """

  syncLoop ()

  // go ()
  // let _ = concurrently startReader startWriter
  // __nativeFun "run_server"
  0
