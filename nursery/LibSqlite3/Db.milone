module rec LibSqlite3.Db

// runtime code must be compiled with this

open Std.IO
open Std.Own
open Std.Ptr
open Std.Region

__nativeDecl "struct sqlite3;"

// definition must be sync with runtime code
type DbValue =
  | DNull
  | DString of string
  | DInt of int

// struct sqlite3 *
type private DbPtr = nativeptr<__nativeType<``struct sqlite3``>>

/// Connection to a database.
// note: not use DbPtr here so that `struct sqlite3 *` doesn't appear in other source files.
type Db = private Db of Own<voidptr>

let private unsafeDup (db: Db) : DbPtr * Db =
  let (Db ownedDbPtr) = db
  let dbPtr = Own.release ownedDbPtr
  Ptr.cast dbPtr, Db(Own.acquire dbPtr)

module Db =
  /// Opens a database file. Create if missing.
  ///
  /// Pass `":memory:"` to create an in-memory database.
  let openFile (io: IO) (pathname: string) : Result<Db, string> * IO =
    let pError: nativeptr<string> =
      __nativeStmt "struct String error;"
      __nativeExpr "&error"

    let p: DbPtr =
      __nativeFun ("db_open", pathname, pError)

    if p <> Ptr.nullPtr then
      Ok(Db(Own.acquire (Ptr.cast p))), io
    else
      Error(Ptr.read pError), io

  // Closes a database file.
  let close (db: Db) : unit =
    let (Db ownedDbPtr) = db
    let dbPtr = Own.release ownedDbPtr
    __nativeFun ("db_close", dbPtr)

  /// Executes a statement to retrieve data.
  let select (sql: string) (paramList: (string * DbValue) list) (db: Db) : Result<DbValue list list, unit> * Db =
    let pRows: nativeptr<DbValue list list> =
      __nativeStmt "struct DbValue_ListCons const *rows = NULL;"
      __nativeExpr "&rows"

    let dbPtr, db = unsafeDup db

    let ok: bool =
      __nativeFun ("db_select", dbPtr, sql, paramList, pRows)

    if ok then
      Ok(Ptr.read pRows), db
    else
      Error(), db

  /// Executes a statement to mutate the database.
  let mutate (sql: string) (paramList: (string * DbValue) list) (db: Db) : bool * Db =
    let dbPtr, db = unsafeDup db

    let ok: bool =
      __nativeFun ("db_mutate", dbPtr, sql, paramList)

    ok, db

  /// Executes multiple statements.
  let exec (sql: string) (db: Db) : Result<unit, string> * Db =
    let pError: nativeptr<string> =
      __nativeStmt "struct String error;"
      __nativeExpr "&error"

    let dbPtr, db = unsafeDup db

    let ok: bool =
      __nativeFun ("db_exec", dbPtr, sql, pError)

    if ok then
      Ok(), db
    else
      Error(Ptr.read pError), db
