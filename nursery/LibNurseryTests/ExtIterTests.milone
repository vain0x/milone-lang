module rec LibNurseryTests.ExtIterTests

module S = MiloneStd.StdString
open LibNursery.ExtIter

let private bang () = exit 1

/// Generates `i`: `0 <= i < n`.
let private gen (n: int) = ExtIter.range 0 n

let private cat (xs: Iter<int>) : int =
  ExtIter.fold (fun n x -> n * 10 + x) 0 xs

let private testNext () =
  let xs: Iter<int> = ExtIter.range 1 4
  let xs1 = xs

  let xs =
    match ExtIter.next xs with
    | None -> bang (assert false)

    | Some (x, xs) ->
      assert (x = 1)
      xs

  let xs =
    match ExtIter.next xs with
    | None -> bang (assert false)

    | Some (x, xs) ->
      assert (x = 2)
      xs

  let xs =
    match ExtIter.next xs with
    | None -> bang (assert false)

    | Some (x, xs) ->
      assert (x = 3)
      xs

  match ExtIter.next xs with
  | None -> ()
  | Some _ -> bang (assert false)

  // fused
  match ExtIter.next xs with
  | None -> ()
  | Some _ -> bang (assert false)

  // it's stateless
  match ExtIter.next xs1 with
  | None -> bang (assert false)

  | Some (x, xs) -> assert (x = 1)

let private testEmpty () =
  let xs : Iter<string> = ExtIter.empty ()

  assert (Option.isNone (ExtIter.next xs))

let private testSingleton () =
  let xs = ExtIter.singleton "foo"

  match ExtIter.next xs with
  | None -> assert false
  | Some (x, xs) ->
    assert (x = "foo")

    match ExtIter.next xs with
    | None -> ()
    | Some _ -> assert false

let private testReplicate () =
  assert (ExtIter.replicate 0 "x" |> ExtIter.isEmpty)

  assert (ExtIter.replicate 2 "x"
          |> ExtIter.toList
          |> S.concat "," = "x,x")

let private testMap () =
  assert (gen 0
          |> ExtIter.map (fun _ -> bang (assert false))
          |> cat = 0)

  assert (gen 3 |> ExtIter.map (fun x -> x + 1) |> cat = 123)

  assert (gen 3
          |> ExtIter.map (fun x -> x * 2)
          |> ExtIter.map (fun x -> x + 1)
          |> cat = 135)

let private testChoose () =
  let n =
    gen 6
    |> ExtIter.choose (fun n -> if n % 2 = 0 then Some(n * 2) else None)
    |> cat

  assert (n = 48)

let private testCollect () =
  let n =
    gen 4
    |> ExtIter.collect (fun n -> ExtIter.replicate n n)
    |> cat

  assert (n = 122333)

let private testScan () =
  let s =
    gen 4
    |> ExtIter.scan (fun n x -> n * 10 + x) 0
    |> ExtIter.map string
    |> ExtIter.toList
    |> S.concat ","

  assert (s = "0,1,12,123")

let private testIsEmpty () =
  assert (gen 0 |> ExtIter.isEmpty)
  assert (gen 1 |> ExtIter.isEmpty |> not)
  assert (gen 2 |> ExtIter.isEmpty |> not)

let private testFold () =
  let xs: Iter<int> = ExtIter.range 1 4
  assert (cat xs = 123)

let private testOfOption () =
  assert (cat (ExtIter.ofOption None) = 0)
  assert (cat (ExtIter.ofOption (Some 2)) = 2)

let private testOfList () =
  let xs: Iter<int> = ExtIter.ofList [ 2; 3; 5 ]
  assert (cat xs = 235)

  let ys = ExtIter.ofList [ 2 ]
  assert (cat ys = 2)

  let zs = ExtIter.ofList []
  assert (cat zs = 0)

let private testToList () =
  let xs =
    ExtIter.ofList [ 2; 3; 5 ] |> ExtIter.toList

  assert (List.fold (fun n x -> n * 10 + x) 0 xs = 235)

  let ys =
    ExtIter.ofList [ "x"; "y"; "z" ] |> ExtIter.toList

  assert (List.fold (fun (x: string) y -> x + y) "" ys = "xyz")

let testExtIterModule () =
  testNext ()
  testEmpty ()
  testSingleton ()
  testReplicate ()
  testMap ()
  testChoose ()
  testCollect ()
  testScan ()
  testIsEmpty ()
  testFold ()
  testOfOption ()
  testOfList ()
  testToList ()
