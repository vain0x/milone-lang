module rec CmdLspServer.Program

open MiloneStd.StdError
open LibSqlite3.Db
open LibJson.Json

module I = MiloneStd.StdInt
module S = MiloneStd.StdString

__nativeDecl
  """
    #include <errno.h>
  """

let private trace (s: string) : unit =
  __nativeStmt ("fwrite({0}.str, sizeof(char), (size_t){0}.len, stderr);", s + "\n")

let private loopInRegion (action: unit -> unit) : int =
  let f =
    fun () ->
      action ()
      0

  let rec go () =
    let code = __inRegion f
    if code = 0 then go () else code

  go ()

// -----------------------------------------------
// IO
// -----------------------------------------------

// notes: Buffer, Stream are copied from LibHttpServer

// ptr, capacity
type private Buffer = nativeptr<byte> * int

module private Buffer =
  let allocate (capacity: int) : Buffer =
    if capacity = 0 then
      __nativeCast (unativeint 1), 0
    else
      assert (capacity >= 1)

      __nativeStmt ("unsigned char *buf = milone_mem_alloc({0}, sizeof(unsigned char));", capacity)

      let ptr: nativeptr<byte> = __nativeExpr "buf"

      ptr, capacity

  /// Converts a buffer to string.
  ///
  /// Use this only when the contents of buffer are valid as UTF-8 (not checked).
  /// Given buffer should never be mutated.
  let toString (len: int) (buf: Buffer) : string =
    let ptr, capacity = buf
    assert (len >= 0)
    assert (len < capacity)
    __nativeStmt ("struct String s = str_of_raw_parts({0}, {1});", ptr, len)
    __nativeExpr "s"

type private Stream = nativeptr<__nativeType<FILE>>

let private getStdin () : Stream = __nativeExpr "stdin"
let private getStdout () : Stream = __nativeExpr "stdout"

/// Reads from stream to fill the buffer.
///
/// Returns size of read data. (Maybe less than capacity.)
let private readBlock (buf: Buffer) (input: Stream) : int * Buffer * Stream =
  let bufPtr, bufSize = buf

  __nativeStmt ("int len = (int)fread({1}, 1, (size_t){2}, {0});", input, bufPtr, bufSize)

  let len: int = __nativeExpr "len"
  len, buf, input

/// Reads a block of bytes equal to specified size.
///
/// Blocks to wait for the buffer to fill.
/// Returns whether read data is of specified size.
let private readExact (buf: Buffer) (size: int) (input: Stream) : bool * Buffer * Stream =
  let bufPtr, bufSize = buf
  assert (size >= 0)
  assert (size <= bufSize)

  __nativeStmt (
    """
      size_t result = fread({1}, (size_t){2}, 1, {0});
      bool ok = result == 1;
    """,
    input,
    bufPtr,
    size
  )

  let ok: bool = __nativeExpr "ok"

  if not ok then
    // let s: nativeptr<char> = __nativeExpr("strerror(errno)")
    // let s: string = __nativeExpr ("str_borrow({0})", s)
    // printfn "%s" s
    printfn "%d" ((__nativeExpr "result": unativeint) |> int)

  ok, buf, input

let private readLine (input: Stream) : string option * Stream =
  __nativeStmt (
    """
      char buf[4000] = "";
      bool ok = fgets(buf, sizeof buf, {0}) != NULL;
    """,
    input
  )

  if __nativeExpr "ok" then
    let line: string = __nativeExpr "str_of_c_str(buf)"
    Some line, input
  else
    None, input

let private doWriteExact (ptr: __constptr<byte>) (len: int) (output: Stream) : unit =
  assert (len >= 1)

  __nativeStmt (
    """
      size_t written = fwrite({1}, {2}, 1, {0});
      bool ok = written == 1;
    """,
    output,
    ptr,
    unativeint len
  )

  let ok: bool = __nativeExpr "ok"
  if not ok then failwith "writeExact"

let private writeString (s: string) (output: Stream) : Stream =
  if s.Length <> 0 then
    let ptr: __constptr<char> = __nativeExpr ("({0}.str)", s)
    let ptr: __constptr<byte> = __nativeCast ptr
    let output = doWriteExact ptr s.Length output
    __nativeStmt ("fflush({0});", output)
    output

  output

// -----------------------------------------------
// JSON
// -----------------------------------------------

module private J =
  let asString j =
    match j with
    | JString value -> value
    | _ -> failwith "expected a string"

  let asInt j =
    match j with
    | JNumber value -> int value
    | _ -> failwith "expected an int"

  let at index (j: JsonValue) : JsonValue =
    match j with
    | JArray items ->
      match items |> List.tryItem index with
      | Some value -> value
      | None -> failwith "out of range"
    | _ -> failwith "expected an array"

  let get key (j: JsonValue) : JsonValue =
    match j with
    | JObject entries ->
      entries
      |> List.tryPick (fun (k, value) -> if k = key then Some value else None)
      |> Option.defaultWith (fun () ->
        // printfn "// %s missing" key
        JNull)

    | _ -> JNull

  let dig keys (j: JsonValue) =
    keys |> List.fold (fun j key -> get key j) j

  let getT2 k1 k2 (j: JsonValue) = get k1 j, get k2 j
  let getT3 k1 k2 k3 (j: JsonValue) = get k1 j, get k2 j, get k3 j

// -----------------------------------------------
// LSP
// -----------------------------------------------

type private MsgId = JsonValue
type private Uri = Uri of string

module private Uri =
  let toString (Uri s) = s

type private DidOpenParam =
  { Uri: Uri
    Version: int
    Text: string }

let private parseDidOpenParam j : DidOpenParam =
  let uri, version, text =
    j
    |> J.get "textDocument"
    |> J.getT3 "uri" "version" "text"

  let uri, version, text =
    Uri(J.asString uri), J.asInt version, J.asString text

  { Uri = uri
    Version = version
    Text = text }

type private DidChangeParam =
  { Uri: Uri
    Version: int
    Text: string }

let private parseDidChangeParam j : DidChangeParam =
  let uri, version =
    let uri, version =
      j
      |> J.get "textDocument"
      |> J.getT2 "uri" "version"

    Uri(J.asString uri), J.asInt version

  let text =
    j
    |> J.get "contentChanges"
    |> J.at 0
    |> J.get "text"
    |> J.asString

  { Uri = uri
    Version = version
    Text = text }

type private DidCloseParam = { Uri: Uri }

let private parseDidCloseParam j : DidCloseParam =
  let uri =
    j
    |> J.dig [ "textDocument"; "uri" ]
    |> J.asString
    |> Uri

  { Uri = uri }

type private LspRequest =
  | InitializeRequest of MsgId * rootOpt: Uri option
  | InitializedNotification
  | ShutdownRequest of MsgId
  | ExitNotification

  | DidOpenNotification of DidOpenParam
  | DidChangeNotification of DidChangeParam
  | DidCloseNotification of DidCloseParam

  | UnknownRequest

let private readRequest () : LspRequest =
  trace "readRequest"

  let input = getStdin ()

  let rec readHeader lenOpt =
    trace (
      "readHeader len="
      + (lenOpt
         |> Option.map string
         |> Option.defaultValue "None")
    )

    match readLine input with
    | None, _ -> failwith "Unexpected EOF"

    | Some line, _ when line |> S.trimEnd = "" ->
      // Hit "\r\n\r\n".
      match lenOpt with
      | None -> failwith "Content-Length header missed."
      | Some len -> len

    | Some header, _ ->
      let key, value, colon = S.cut ":" header

      if not colon then
        failwith ("Illegal header: '" + header + "'")

      let key = S.trim key
      let value = S.trim value

      match key with
      | "Content-Length" ->
        match I.tryParse value with
        | None -> failwith ("Can't parse length as integer: '" + value + "'")
        | Some len -> readHeader (Some len)

      | _ ->
        trace ("Ignore header: '" + key + "'")
        readHeader lenOpt

  let readBody (len: int) : string =
    trace ("readBody len=" + string len)

    if len >= 10100100 then
      failwith ("Content-length too large: '" + string len + "'")

    let body = Buffer.allocate (len + 1)
    let ok, body, _ = readExact body len input

    if not ok then
      failwith ("Couldn't read request body.")

    body |> Buffer.toString len

  let len = readHeader None
  let body = readBody len
  let req = jsonParseFromString body
  let msgId = req |> J.get "id"
  let m = req |> J.get "method"
  let p = req |> J.get "params"

  match m with
  | JString "initialize" ->
    let rootOpt =
      match p |> J.get "rootUri" with
      | JString it -> Some(Uri it)
      | _ -> None

    InitializeRequest(msgId, rootOpt)

  | JString "initialized" -> InitializedNotification

  | JString "shutdown" -> ShutdownRequest msgId
  | JString "exit" -> ExitNotification

  | JString "textDocument/didOpen" -> DidOpenNotification(parseDidOpenParam p)
  | JString "textDocument/didChange" -> DidChangeNotification(parseDidChangeParam p)
  | JString "textDocument/didClose" -> DidCloseNotification(parseDidCloseParam p)

  | JString m ->
    trace ("unknown method: '" + m + "'")
    UnknownRequest

  | _ ->
    trace ("unknown method without method")
    UnknownRequest

// -----------------------------------------------
// Persistent
// -----------------------------------------------

let private dumpDbTable tableName =
  let cons h t = h :: t
  let consBetween l r x acc = r :: x :: l :: acc

  let dumpRow row acc =
    row
    |> List.mapi (fun i value -> i, value)
    |> List.fold
         (fun acc (i, value) ->
           let acc = if i = 0 then acc else acc |> cons ", "

           match value with
           | DNull -> acc |> cons "null"
           | DInt n -> acc |> cons (string n)
           | DString s ->
             if s.Length <= 32 && s |> S.contains "\n" |> not then
               acc |> consBetween "\"" "\"" s
             else
               acc
               |> consBetween "<string " ">" (string s.Length))
         acc

  let dumpRows rows acc =
    rows
    |> List.mapi (fun i row -> i, row)
    |> List.fold
         (fun acc (i, row) ->
           let acc = if i = 0 then acc else acc |> cons "\n"
           dumpRow row acc)
         acc

  let rows =
    dbSelect ("select * from " + tableName) []

  dumpRows rows []
  |> List.rev
  |> S.concat ""
  |> printfn "%s"

let private dbInit () =
  dbOpen ":memory:"

  dbExec
    """
      create table if not exists docs(
        uri varchar(300) primary key,
        version int not null,
        text text not null
      );
    """

let private dbAddDoc uri version text =
  dbMutate
    """
      insert into docs(uri, version, text) values
        (:uri, :version, :text)
    """
    [ ":uri", DString uri
      ":version", DInt version
      ":text", DString text ]

let private dbUpdateDoc uri version text =
  dbMutate
    """
      update docs set
          version = :version,
          text = :text
      where
          uri = :uri
    """
    [ ":uri", DString uri
      ":version", DInt version
      ":text", DString text ]

let private dbRemoveDoc uri =
  dbMutate "delete from docs where uri = :uri" [ ":uri", DString uri ]

// -----------------------------------------------
// Interface
// -----------------------------------------------

let private initializedResponse () =
  """{
    "capabilities": {
        "textDocumentSync": {
            "openClose": true,
            "change": 1
        },
        "definitionProvider": true,
        "documentHighlightProvider": true,
        "documentFormattingProvider": true,
        "hoverProvider": true,
        "referencesProvider": true,
        "renameProvider": false
    },
    "serverInfo": {
        "name": "milone_lsp",
        "version": "0.1.0"
    }
  }"""

[<EntryPoint>]
let main _ =
  trace "Hello, lsp server!"

  let output = getStdout ()

  loopInRegion (fun () ->
    match readRequest () with
    | InitializeRequest (msgId, rootOpt) ->
      let root =
        match rootOpt with
        | Some uri -> uri |> Uri.toString
        | _ -> "null"

      trace ("rootUri = " + root)

      let response =
        ("""{ "jsonrpc": "2.0", "id": ${MSG_ID}, "result": ${RESULT} }"""
         + "\n")
        |> S.replace "${MSG_ID}" (jsonToString msgId)
        |> S.replace "${RESULT}" (initializedResponse ())

      writeString
        ("Content-Length: "
         + string response.Length
         + "\r\n\r\n"
         + response)
        output
      |> ignore

    | InitializedNotification -> dbInit ()

    | ShutdownRequest msgId ->
      let response =
        ("""{ "jsonrpc": "2.0", "id": ${MSG_ID}, "result": null }"""
         + "\n")
        |> S.replace "${MSG_ID}" (jsonToString msgId)

      writeString
        ("Content-Length: "
         + string response.Length
         + "\r\n\r\n"
         + response)
        output
      |> ignore

      trace "dump docs:"
      dumpDbTable "docs"

    | ExitNotification ->
      trace "Exit gracefully."
      exit 0

    | DidOpenNotification p ->
      let uri = p.Uri |> Uri.toString
      dbAddDoc uri p.Version p.Text

    | DidChangeNotification p ->
      let uri = p.Uri |> Uri.toString
      dbUpdateDoc uri p.Version p.Text

    | DidCloseNotification p ->
      let uri = p.Uri |> Uri.toString
      dbRemoveDoc uri

    | UnknownRequest -> trace "Ignore unknown request.")
