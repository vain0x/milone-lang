module rec LibNursery.EphRef

open LibNursery.EphSerial
open LibNursery.Runtime

module Ptr = Std.Ptr

/// Ephemeral reference cell.
///
/// This allows a value to be explicitly indirect
/// to reduce cost of copying large data.
///
/// Unlike `ref` in F#, EphRef is not a way to *share*.
/// EphRef is almost equivalent to `Box` in Rust.
type EphRef<'T> = nativeptr<'T> * EphSerial

module rec EphRef =
  /// Creates a reference cell, initialized with specified value.
  let create (value: 'T) (serial: EphSerial) : EphRef<'T> * EphSerial =
    let size = unativeint (sizeof<__inptr<'T>>)

    let ptr = __nativeCast (memAlloc 1 size)
    Ptr.write (ptr: nativeptr<'T>) value
    let refSerial, serial = EphSerial.create serial // TASK: use single allocation for value and serial
    (ptr, refSerial), serial

  /// Gets whether the cell is alive (in terms of ephemeral structure).
  let alive (r: EphRef<_>) : bool * EphRef<_> =
    let ptr, serial = r
    let ok, serial = EphSerial.alive serial
    ok, (ptr, serial)

  /// Gets whether two cells are referentially same.
  let equivalent (l: EphRef<'T>) (r: EphRef<'T>) : bool =
    let (lPtr, _) = l
    let (rPtr, _) = r
    unativeint lPtr = unativeint rPtr

  /// Gets current value.
  let read (r: EphRef<'T>) : 'T * EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    let current =
      Ptr.read (__nativeCast ptr: __inptr<'T>)

    current, (ptr, serial)

  /// Writes new value to reference cell.
  let write (value: 'T) (r: EphRef<'T>) : EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    Ptr.write ptr value
    ptr, serial

  /// Gets current value and then writes new value.
  let replace (next: 'T) (r: EphRef<'T>) : 'T * EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    let prev =
      Ptr.read (__nativeCast ptr: __inptr<'T>)

    Ptr.write ptr next
    prev, (ptr, serial)
