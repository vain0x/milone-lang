module rec LibNursery.EphRef

open LibNursery.EphSerial
open LibNursery.Runtime

/// Ephemeral reference cell.
///
/// This allows a value to be explicitly indirect
/// to reduce cost of copying large data.
///
/// Unlike `ref` in F#, EphRef is not a way to *share*.
/// EphRef is almost equivalent to `Box` in Rust.
type EphRef<'T> = nativeptr<'T> * EphSerial

module rec EphRef =
  /// Creates a reference cell, initialized with specified value.
  let create (value: 'T) : EphRef<'T> =
    let size =
      __sizeOfVal (__nativeCast (unativeint 0): __constptr<'T>)
      |> unativeint

    let ptr = __nativeCast (memAlloc 1 size)
    __ptrWrite ptr 0 value
    ptr, EphSerial.create () // TASK: use single allocation for value and serial

  /// Gets whether the cell is alive (in terms of ephemeral structure).
  let alive (r: EphRef<'_>) : bool =
    let _, serial = r
    EphSerial.alive serial

  /// Gets whether two cells are referentially same.
  let equivalent (l: EphRef<'T>) (r: EphRef<'T>) : bool =
    let (lPtr, _) = l
    let (rPtr, _) = r
    unativeint lPtr = unativeint rPtr

  /// Gets current value.
  let read (r: EphRef<'T>) : 'T * EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    let current =
      __ptrRead (__nativeCast ptr: __constptr<'T>) 0

    current, (ptr, serial)

  /// Writes new value to reference cell.
  let write (value: 'T) (r: EphRef<'T>) : EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    __ptrWrite ptr 0 value
    ptr, serial

  /// Gets current value and then writes new value.
  let replace (next: 'T) (r: EphRef<'T>) : 'T * EphRef<'T> =
    let ptr, serial = r

    // Refresh before access.
    let serial = EphSerial.refresh serial

    let prev =
      __ptrRead (__nativeCast ptr: __constptr<'T>) 0

    __ptrWrite ptr 0 next
    prev, (ptr, serial)
