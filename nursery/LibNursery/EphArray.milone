module rec LibNursery.EphArray

open LibNursery.EphSerial
open LibNursery.Runtime

// buffer ptr, length, serial
/// Ephemeral mutable array.
type EphArray<'T> = nativeptr<'T> * int * EphSerial

module EphArray =
  module Unsafe =
    /// Allocates an array with specified length.
    ///
    /// SAFETY: Contents are zero-filled.
    ///         All of contents must be written before the array is exposed
    ///         if zero-fill is invalid for the type.
    let zeroCreate (len: int) : EphArray<'T> =
      if len <= 0 then
        assert (len = 0 || violate "negative length")
        empty ()
      else
        let size =
          __sizeOfVal (__ptrRead (__nativeCast (unativeint 0): __constptr<'T>) 0)
          |> unativeint

        let ptr = memAlloc len size |> __nativeCast

        ptr, len, EphSerial.create () // TASK: should use single allocation

    let asMut (array: EphArray<'T>) : nativeptr<'T> * EphArray<'T> =
      let array = assertAlive array
      let ptr, _, _ = array
      ptr, array

    let asPtr (array: EphArray<'T>) : __constptr<'T> * EphArray<'T> =
      let array = assertAlive array
      let ptr, _, _ = array
      __nativeCast ptr, array

  let alive (array: EphArray<'T>) : bool * EphArray<'T> =
    let ptr, len, serial = array
    let ok, serial = EphSerial.alive serial
    ok, (ptr, len, serial)

  let private assertAlive (array: EphArray<_>) : EphArray<_> =
    let ok, array = alive array
    assert (ok || violate "no longer alive")
    array

  let private refresh (array: EphArray<'T>) : EphArray<'T> =
    let ptr, len, serial = array
    ptr, len, EphSerial.refresh serial

  /// Gets an ephemeral array with length 0.
  let empty () : EphArray<_> =
    __nativeCast (unativeint 0), 0, EphSerial.create () // TASK: should not allocate

  /// Creates an array with specified length.
  /// `i`'th item is initialized with `f i`.
  ///
  /// That is, `[| f 0; f 1; ...; f (len - 1) |]` is created.
  let init (len: int) (f: int -> 'T) : EphArray<'T> =
    let output = Unsafe.zeroCreate len
    let ptr, _, _ = output

    let rec go i =
      if i < len then
        __ptrWrite ptr i (f i)
        go (i + 1)

    go 0
    output

  /// Creates an array with specified length and filled by specified value.
  ///
  /// That is, `[| item; item; ...; item |]` is created.
  let replicate (len: int) (item: 'T) : EphArray<'T> =
    let output = Unsafe.zeroCreate len
    let ptr, _, _ = output

    let rec ephArrayReplicateLoop i =
      if i < len then
        __ptrWrite ptr i item
        ephArrayReplicateLoop (i + 1)

    ephArrayReplicateLoop 0
    output

  /// Gets length.
  ///
  /// (This doesn't outdate the array reference because length never changes.)
  let length (array: EphArray<_>) : int =
    let _, len, _ = assertAlive array
    len

  /// Gets i'th item. Out of range is fatal error.
  let item (i: int) (array: EphArray<'T>) : 'T * EphArray<'T> =
    assert (unativeint i < unativeint (length array)
            || violate "out of range")

    let array = assertAlive array
    let ptr, _, _ = array
    __ptrRead (__nativeCast ptr) i, array

  /// Gets i'th item. Returns None if out of range. Fatal error if outdated.
  let tryItem (i: int) (array: EphArray<'T>) : 'T option * EphArray<'T> =
    let array = assertAlive array

    if unativeint i < unativeint (length array) then
      let ptr, _, _ = array
      Some(__ptrRead (__nativeCast ptr) i), array
    else
      None, array

  /// Writes to i'th item. Out of range is fatal error.
  let setItem (i: int) (value: 'T) (array: EphArray<'T>) : EphArray<'T> =
    assert (unativeint i < unativeint (length array))

    let array = refresh array
    let ptr, _, _ = array
    __ptrWrite ptr i value
    array
