module rec LibNursery.EphSerial

open LibNursery.Runtime

/// Special object to represent ownership of ephemeral value.
///
/// This object can be used in a module to enforce
/// the user is using single value at most once.
/// (See EphArray for example.)
///
/// In other words, EphSerial is a tool
/// to make order of computation explicit.
/// Could be also called as "version".
type EphSerial = EphSerial of uint * nativeptr<uint>

// Meant to prevent copy propagation. (Actually such optimization is yet implemented though.)
let private blackbox (f: unit -> EphSerial) : EphSerial = f ()

module rec EphSerial =
  /// Creates a fresh serial.
  let create () : EphSerial =
    let ptr : nativeptr<uint> =
      memAlloc 1 (unativeint (__sizeOfVal (unativeint 0)))
      |> __nativeCast

    __ptrWrite ptr 0 (uint 0)
    EphSerial(uint 0, ptr)

  /// Gets whether two serials are equivalent (i.e. serials for the same timeline).
  let equivalent (l: EphSerial) (r: EphSerial) : bool =
    let (EphSerial (_, lPtr)) = l
    let (EphSerial (_, rPtr)) = r
    (__nativeCast lPtr: unativeint) = __nativeCast rPtr

  /// Checks specified serial is alive (not outdated).
  let alive (serial: EphSerial) : bool * EphSerial =
    let (EphSerial (current, ptr)) = serial
    __ptrRead (__nativeCast ptr) 0 = current, blackbox (fun () -> serial)

  /// Creates a fresh serial. After this, specified serial is outdated (no longer alive).
  let refresh (serial: EphSerial) : EphSerial =
    let ok, serial = alive serial
    assert (ok || violate "no longer alive")

    let (EphSerial (current, ptr)) = serial
    let next = current + uint 1
    __ptrWrite ptr 0 next // should increment atomically
    EphSerial(next, ptr)
