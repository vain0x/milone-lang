module rec LibNursery.Impure

open LibNursery.EphSerial

/// Representation of an impure action.
///
/// Note: almost equivalent to `IO` type in Haskell (if I understand correctly).
type Impure<'T> = EphSerial -> 'T * EphSerial

module Impure =
  /// Executes an impure action and *exits the process* with returned code.
  ///
  /// Meant to wrap body of `main` function.
  ///
  // Note that the programming pattern using Impure type keeps the program pure,
  // `exec` itself still makes the language impure.
  let exec (action: Impure<int>) : _ =
    EphSerial.run
      (fun serial ->
        let exitCode, serial = action serial
        let ok, _ = EphSerial.alive serial
        assert ok
        exit exitCode)

  /// Creates an impure action that doesn't do anything
  /// but returns the specified value.
  let just (value: 'T) : Impure<'T> =
    fun (serial: EphSerial) -> value, serial

  /// Creates an impure action from pure function.
  let ofFun (f: unit -> 'T) : Impure<'T> = fun (serial: EphSerial) -> f (), serial

  /// Appends some conversion to an impure action.
  ///
  /// Meant to tweak the result value of action.
  let map (second: 'T -> 'U) (first: Impure<'T>) : Impure<'U> =
    fun serial ->
      let (x: 'T), serial = first serial
      second x, serial

  /// Appends further computation to an impure action.
  ///
  /// Meant to compose an action from smaller ones.
  let andThen (second: 'T -> Impure<'U>) (first: Impure<'T>) : Impure<'U> =
    fun serial ->
      let (x: 'T), serial = first serial
      second x serial
