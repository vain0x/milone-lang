module rec LibNursery.ExtIter

type private NextFun<'S, 'T> = 'S -> ('T * 'S) option

// The implementation of the Iter type.
//
// If generic nominal type were implemented,
// iterator (enumerator in .NET) would be defined as:
//    Iter<'T> = Iter of unit -> ('T * Iter<'T>) option
//
// The recursion of type can be avoided by
// splitting the function and the state that changes during iteration.
// That is:
//    Iter<'T> = (forall 'S => 'S -> ('T * 'S) option)
//
// `forall` is not supported (no plan to support).
// 'S is just replaced by obj here.

/// Iterator, abstraction of iteration.
///
/// Also known as "enumerator" in .NET.
/// Iterator is stateless and different than IEnumerator.
type Iter<'T> = NextFun<obj, 'T> * obj

module rec ExtIter =
  let next (xs: Iter<'T>) : ('T * Iter<'T>) option =
    let nextFun, state = xs

    match nextFun state with
    | None -> None
    | Some (item, state) ->
      let xs: Iter<'T> = nextFun, state
      Some(item, xs)

  // ---------------------------------------------
  // Constructor
  // ---------------------------------------------

  let empty () : Iter<'T> =
    let nextFun (_: obj) : ('T * obj) option = None
    nextFun, box ()

  let singleton (item: 'T) : Iter<'T> = ofList [ item ]

  let replicate (count: int) (item: 'T) : Iter<'T> = range 0 count |> map (fun _ -> item)

  let range (start: int) (endIndex: int) : Iter<int> =
    let nextFun state =
      let i = unbox state

      if i < endIndex then
        Some(i, box (i + 1))
      else
        None

    nextFun, box start

  // ---------------------------------------------
  // Transformer
  // ---------------------------------------------

  /// Extended `scan`.
  let private scanEx (f: 'S -> 'T -> Iter<'U> * 'S) (state: 'S) (xs: Iter<'T>) : Iter<'U> =
    let innerNextFun, innerState = xs

    let pack (subIterOpt: Iter<'U> option) (innerState: obj) (state: 'S) = box (subIterOpt, innerState, state)
    let unpack (outerState: obj) : Iter<'U> option * obj * 'S = unbox outerState

    let rec scanExLoop
      (ysOpt: Iter<'U> option)
      (innerState: obj)
      (state: 'S)
      : ('U * (Iter<'U> option * obj * 'S)) option =
      match ysOpt with
      | Some ys ->
        match next ys with
        | None -> scanExLoop None innerState state
        | Some (y, ys) -> Some(y, (Some ys, innerState, state))

      | None ->
        match innerNextFun innerState with
        | None -> None

        | Some (x, innerState) ->
          let ys, state = f state x
          scanExLoop (Some ys) innerState state

    let nextFun outerState : ('U * obj) option =
      let ysOpt, innerState, state = unpack outerState

      match scanExLoop ysOpt innerState state with
      | None -> None
      | Some (y, (ysOpt, innerState, state)) -> Some(y, pack ysOpt innerState state)

    nextFun, pack None innerState state

  let map (f: 'T -> 'U) (xs: Iter<'T>) : Iter<'U> =
    scanEx (fun () (x: 'T) -> singleton (f x), ()) () xs

  let choose (f: 'T -> 'U option) (xs: Iter<'T>) : Iter<'U> =
    scanEx (fun () (x: 'T) -> ofOption (f x), ()) () xs

  let collect (f: 'T -> Iter<'U>) (xs: Iter<'T>) : Iter<'U> =
    scanEx (fun () (x: 'T) -> f x, ()) () xs

  let scan (folder: 'S -> 'T -> 'S) (state: 'S) (xs: Iter<'T>) : Iter<'S> =
    scanEx
      (fun state x ->
        let state = folder state x
        singleton state, state)
      state
      xs

  // ---------------------------------------------
  // Consumer
  // ---------------------------------------------

  let isEmpty (xs: Iter<_>) : bool = Option.isNone (next xs)

  // wants Result<'S, 'A>, use 'S option * 'A option instead
  /// Runs an iterator updating a state.
  ///
  /// `folder state item` computes the next state `Ok s`
  /// or returns `Err a` to break from the iteration.
  let private foldEx (folder: 'S -> 'T -> 'S option * 'A option) (complete: 'S -> 'A) (state: 'S) (xs: Iter<'T>) : 'A =
    let nextFun, iterState = xs

    let rec foldExLoop (state: 'S) (iterState: obj) : 'A =
      match nextFun iterState with
      | None -> complete state

      | Some (item, iterState) ->
        match folder state item with
        | Some state, None -> foldExLoop state iterState
        | None, Some result -> result
        | _ ->
          assert false
          exit 1

    foldExLoop state iterState

  let fold (folder: 'S -> 'T -> 'S) (state: 'S) (xs: Iter<'T>) : 'S =
    foldEx (fun state item -> Some(folder state item), None) id state xs

  // ---------------------------------------------
  // Option
  // ---------------------------------------------

  let ofOption (opt: 'T option) : Iter<'T> =
    match opt with
    | Some item -> singleton item
    | None -> ofList []

  // ---------------------------------------------
  // List
  // ---------------------------------------------

  let ofList (xs: 'T list) : Iter<'T> =
    let nextFun (state: obj) : ('T * obj) option =
      match unbox state with
      | [] -> None
      | x :: xs -> Some(x, box xs)

    nextFun, box xs

  let toList (xs: Iter<'T>) : 'T list =
    xs |> fold (fun xs x -> x :: xs) [] |> List.rev
