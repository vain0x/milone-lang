module rec CmdCat.Program

open CmdCat.Ffi
open Std.IO
open Std.File
open Std.Own
open Std.Ptr
open Std.StdError
open Std.StdList
open Std.Vector

module Env = Std.StdEnv

// should be in Std.File
module File =
  /// Writes contents of ByteVector to a file.
  let writeBlock (io: IO) (buf: Vector<byte>) (file: File) : bool * File * Vector<byte> * IO =
    let ptr, len, _, buf = VectorExt.unsafeDup buf

    if len <> 0u then
      let ok, file, io =
        File.unsafeWriteExactFromRawParts io (Ptr.cast ptr) (int len) file

      let file, io =
        if ok then
          File.flush io file
        else
          file, io

      ok, file, buf, io
    else
      true, file, buf, io

// -----------------------------------------------
// Application
// -----------------------------------------------

let private helpText () =
  """cat: Concatenates multiple files

USAGE:
   cat <FILE...>

EXAMPLES:
    # Write concatenation of input1.txt and input2.txt to standard output.
    cat input1.txt input2.txt

    # Pipe standard input to standard output.
    cat -

ARGUMENTS:
  FILE: pathname of file to read from.
        '-' for standard input."""

/// Reads a file and writes its contents to standard output.
let private doCatFile (io: IO) profiler (output: File) pathname =
  let rec readLoop (io: IO) profiler input output buf =
    let profiler = Profiler.log "READ" profiler

    let readSize, buf, input, io = File.readBlock io buf input

    if readSize < 0 then
      Vector.dispose buf // buf seems not consumed here; compiler bug?

      Error("read: '" + pathname + "'"), io, profiler, input, output, buf
    else if readSize = 0 then
      // reached at EOF
      Ok(), io, profiler, input, output, buf
    else
      let ok, output, buf, io = File.writeBlock io buf output

      if not ok then
        Error "Write failed", io, profiler, input, output, buf
      else
        let buf = VectorExt.unsafeSetLength 0 buf // wants Vector.clear

        readLoop io profiler input output buf

  let profiler =
    Profiler.log ("OPEN: " + pathname) profiler

  let inputOpt, io =
    if pathname = "-" then
      Some(File.stdin ()), io
    else
      File.openRead io pathname

  match inputOpt with
  | None -> Error("open: '" + pathname + "'"), io, profiler, output

  | Some input ->
    let buf: Vector<byte> = Vector.alloc 1000

    let result, io, profiler, input, output, buf = readLoop io profiler input output buf

    let io = File.close io input
    Vector.dispose buf

    let profiler = Profiler.log "CLOSED" profiler

    result, io, profiler, output

let private catFiles (io: IO) profiler output (inputs: string list) =
  match inputs with
  | [] -> Ok(), io, profiler, output

  | pathname :: inputs ->
    let result, io, profiler, output = doCatFile io profiler output pathname

    match result with
    | Ok () -> catFiles io profiler output inputs
    | Error msg -> Error msg, io, profiler, output

// -----------------------------------------------
// Entrypoint
// -----------------------------------------------

let main _ =
  let args = Env.commandLineArgs () |> List.drop 1

  IO.exec (fun io ->
    match args with
    | []
    | "-h" :: "--help" :: _ ->
      printfn "%s" (helpText ())
      io

    | _ ->
      let profiler = Profiler.create ()
      let output = File.stdout ()

      let result, io, profiler, output = catFiles io profiler output args

      let io = File.close io output
      Profiler.dispose profiler

      match result with
      | Ok () -> io

      | Error msg ->
        printfn "ERROR: %s" msg
        exit 1
        io)
  |> never
