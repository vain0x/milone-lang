module rec CmdCat.Program

open CmdCat.Ffi
open Std.IO
open Std.File
open Std.Own
open Std.Ptr
open Std.StdError
open Std.StdList
open Std.Vector

module Env = Std.StdEnv

// should be in Std.File
module File =
  /// Writes contents of ByteVector to a file.
  let writeBlock (io: IO) (buf: Vector<byte>) (file: File) : bool * File * Vector<byte> * IO =
    let ptr, len, _, buf = VectorExt.unsafeDup buf

    if len <> 0u then
      let ok, file, io =
        File.unsafeWriteExactFromRawParts io (Ptr.cast ptr) (int len) file

      let file, io =
        if ok then
          File.flush io file
        else
          file, io

      ok, file, buf, io
    else
      true, file, buf, io

// -----------------------------------------------
// Application
// -----------------------------------------------

/// Reads a file and writes its contents to standard output.
let private doCatFile (io: IO) profiler (output: File) pathname =
  let rec readLoop (io: IO) profiler input output buf =
    let profiler = Profiler.log "READ" profiler

    let readSize, buf, input, io = File.readBlock io buf input

    if readSize < 0 then
      Vector.dispose buf // buf seems not consumed here; compiler bug?

      Error("read: '" + pathname + "'"), io, profiler, input, output, buf
    else if readSize = 0 then
      // reached at EOF
      Ok(), io, profiler, input, output, buf
    else
      let ok, output, buf, io = File.writeBlock io buf output

      if not ok then
        Error "Write failed", io, profiler, input, output, buf
      else
        let buf = VectorExt.unsafeSetLength 0 buf // wants Vector.clear

        readLoop io profiler input output buf

  let profiler =
    Profiler.log ("OPEN: " + pathname) profiler

  let inputOpt, io = File.openRead io pathname

  match inputOpt with
  | None -> Error("open: '" + pathname + "'"), io, profiler, output

  | Some input ->
    let buf: Vector<byte> = Vector.alloc 1000

    let result, io, profiler, input, output, buf = readLoop io profiler input output buf

    let io = File.close io input
    Vector.dispose buf

    let profiler = Profiler.log "CLOSED" profiler

    result, io, profiler, output

let private catFiles (io: IO) profiler output (inputs: string list) =
  let rec loop (io: IO) profiler output inputs =
    match inputs with
    | [] -> Ok(), io, profiler, output

    | pathname :: inputs ->
      let result, io, profiler, output = doCatFile io profiler output pathname

      match result with
      | Ok () -> catFiles io profiler output inputs
      | Error msg -> Error msg, io, profiler, output

  match inputs with
  | [] -> Error "No inputs.", io, profiler, output

  | _ -> loop io profiler output inputs

// -----------------------------------------------
// Entrypoint
// -----------------------------------------------

let main _ =
  let args = Env.commandLineArgs () |> List.drop 1

  IO.exec (fun io ->
    let profiler = Profiler.create ()
    let output = File.stdout ()

    let result, io, profiler, output = catFiles io profiler output args

    let io = File.close io output
    Profiler.dispose profiler

    match result with
    | Ok () -> io

    | Error msg ->
      printfn "ERROR: %s" msg
      exit 1
      io)
  |> never
