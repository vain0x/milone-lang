module rec CmdCat.Program

open CmdCat.Ffi
open Std.IO
open Std.File
open Std.Own
open Std.Ptr
open Std.StdError
open Std.StdList
open Std.Vector

module Env = Std.StdEnv

// should be in Std.File
module File =
  let flush (io: IO) (file: File) : File * IO =
    let fp = FileExt.unsafeUnwrap file
    let fp = Own.release fp

    __nativeStmt ("fflush({0});\n", fp)

    let file = FileExt.unsafeWrap (Own.acquire fp)
    file, io

  let writeBlock (io: IO) (buf: Vector<byte>) (file: File) : bool * File * Vector<byte> * IO =
    let ptr, len, _, buf = VectorExt.unsafeDup buf

    if len <> 0u then
      let ok, file, io =
        File.unsafeWriteExactFromRawParts io (Ptr.cast ptr) (int len) file

      let file, io = if ok then flush io file else file, io

      ok, file, buf, io
    else
      true, file, buf, io

// -----------------------------------------------
// Application
// -----------------------------------------------

/// Reads a file and writes its contents to standard output.
let private doCatFile (io: IO) profiler (output: File) pathname =
  let rec readLoop (io: IO) profiler input output buf =
    let profiler = Profiler.log "READ" profiler

    let readSize, buf, input, io = File.readBlock io buf input

    let bufLen, buf = Vector.length buf

    // FIXME: readBlock should do this
    let buf = VectorExt.unsafeSetLength readSize buf

    if readSize < 0 then
      Vector.dispose buf // buf seems not consumed here; compiler bug?

      Error("read: '" + pathname + "'"), io, profiler, input, output, buf
    else if readSize = 0 then
      // reached at EOF
      Ok(), io, profiler, input, output, buf
    else
      let ok, output, buf, io = File.writeBlock io buf output

      if not ok then
        Error "Write failed", io, profiler, input, output, buf
      else
        let buf = VectorExt.unsafeSetLength 0 buf // wants Vector.clear

        readLoop io profiler input output buf

  let profiler =
    Profiler.log ("OPEN: " + pathname) profiler

  let inputOpt, io = File.openRead io pathname

  match inputOpt with
  | None -> Error("open: '" + pathname + "'"), io, profiler, output

  | Some input ->
    let buf: Vector<byte> = Vector.alloc 1000

    let result, io, profiler, input, output, buf = readLoop io profiler input output buf

    let io = File.close io input
    Vector.dispose buf

    let profiler = Profiler.log "CLOSED" profiler

    result, io, profiler, output

let main _ =
  let args = Env.commandLineArgs () |> List.drop 1

  if args |> List.isEmpty then
    failwith "No argument. Usage: cat <FILE>"
  else
    IO.exec (fun io ->
      let output = File.stdout ()

      let profiler = Profiler.create ()
      let profiler = Profiler.log "START" profiler

      let rec go (io: IO) profiler output args =
        match args with
        | [] -> Ok(), io, profiler, output

        | arg :: args ->
          let result, io, profiler, output = doCatFile io profiler output arg

          match result with
          | Error msg -> Error msg, io, profiler, output
          | Ok () -> go io profiler output args

      let result, io, profiler, output = go io profiler output args

      let io = File.close io output

      let profiler = Profiler.log "FINISH" profiler
      Profiler.dispose profiler

      match result with
      | Ok () -> io

      | Error msg ->
        printfn "ERROR: %s" msg
        exit 1
        io)
    |> never
