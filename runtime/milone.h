// Runtime code for C programs generated by the milone-lang compiler.

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// null-terminated string
struct String {
  char* str;
  int len;
};

// -----------------------------------------------
// memory management (memory pool)
// -----------------------------------------------

// structure for memory management. poor implementation. thread unsafe.
struct MemoryChunk {
  // start of allocated memory
  void* start_ptr;
  // total capacity
  size_t start_cap;

  // ptr to unused part
  void* next_ptr;
  // size of unused part
  size_t next_cap;

  // parent chunk in full list
  struct MemoryChunk* next;
};

struct MemoryRegion {
  // small[h] stores objects with size (m * 2^h)
  struct MemoryChunk small[16];

  // list of full chunks or null
  // chunks are linked by MemoryChunk.next and allocated on heap
  struct MemoryChunk* full;

  // parent region or null
  struct MemoryRegion* parent;
};

static struct MemoryRegion* s_heap;
static int s_heap_level; // depth of current region
static int s_heap_size; // consumed size in all regions
static int s_heap_alloc;  // allocated size in all regions

static void oom() {
  fprintf(stderr, "Out of memory.\n");
  exit(1);
}

static void free_chunk(struct MemoryChunk* chunk) {
  assert(chunk != NULL);

  free(chunk->start_ptr);
  s_heap_size -= chunk->start_cap - chunk->next_cap;
  s_heap_alloc -= chunk->start_cap;
}

static void free_region(struct MemoryRegion* region) {
  for (int i = 0; i < 16; i++) {
    free_chunk(&region->small[i]);
  }

  struct MemoryChunk* full = region->full;
  while (full != NULL) {
    struct MemoryChunk* chunk = full;
    full = full->next;

    free_chunk(chunk);
    free(chunk);
  }
}

void milone_enter_region(void) {
  // fprintf(stderr, "debug: enter_region level=%d size=%d\n", s_heap_level + 1, s_heap_size);

  struct MemoryRegion* region = calloc(1, sizeof(struct MemoryRegion));
  if (region == NULL) {
    oom();
  }

  region->parent = s_heap;
  s_heap = region;
  s_heap_level++;
}

void milone_leave_region(void) {
  // fprintf(stderr, "debug: leave_region level=%d size=%d\n", s_heap_level, s_heap_size);

  assert(s_heap_level > 0);
  s_heap_level--;

  struct MemoryRegion* region = s_heap;
  assert(region != NULL);
  s_heap = region->parent;

  // free all memory allocated in the region
  free_region(region);
  free(region);

  // fprintf(stderr, "debug: free level=%d size=%d\n", s_heap_level, s_heap_size);
}

// allocate large data
static void* milone_mem_alloc_large(int count, size_t size) {
  assert((size_t)count * size >= (1 << 16));

  void* ptr = calloc((size_t)count, size);
  if (ptr == NULL) {
    oom();
  }

  struct MemoryChunk* chunk = calloc(1, sizeof(struct MemoryChunk));
  if (chunk == NULL) {
    oom();
  }
  *chunk = (struct MemoryChunk){
    .start_ptr = ptr,
    .start_cap = (size_t)count * size,
    .next_ptr = NULL,
    .next_cap = 0,
    .next = s_heap->full,
  };
  s_heap->full = chunk;

  s_heap_size += (size_t)count * size;
  s_heap_alloc += (size_t)count * size;

  // fprintf(stderr, "debug: alloc level=%d size=%d  large\n", s_heap_level, (int)(count * size));
  return ptr;
}

// allocate new chunk
static void* milone_mem_alloc_slow(int h, struct MemoryChunk* chunk, size_t size) {
  size_t cap = chunk->start_cap;

  // move chunk to full list
  if (chunk->start_ptr != NULL) {
    struct MemoryChunk* full = malloc(sizeof(struct MemoryChunk));
    if (full == NULL) {
      oom();
    }

    *full = *chunk;
    full->next = s_heap->full;
    s_heap->full = full;
  }

  // grow exponentially
  cap *= 2;
  if (cap < size) {
    cap = size;
  }

  // initialize chunk
  void* ptr = calloc(1, cap);
  if (ptr == NULL) {
    oom();
  }
  *chunk = (struct MemoryChunk){
    .start_ptr = ptr,
    .start_cap = cap,
    .next_ptr = (char*)ptr + size,
    .next_cap = cap - size,
    .next = NULL,
  };
  s_heap_size += size;
  s_heap_alloc += cap;

  // fprintf(stderr, "debug: alloc level=%d size=%d  new chunk(h=%d cap=%d)\n", s_heap_level, (int)size, h, (int)cap);
  return ptr;
}

void* milone_mem_alloc(int count, size_t size) {
  if (count == 0 || size == 0) {
    return "";
  }

  size_t total = (size_t)count * size;
  if (total >= (1 << 16)) {
    return milone_mem_alloc_large(count, size);
  }

  // find bin. (use __builtin_ctz?)
  size_t h = 0;
  while ((total & ((1 << (h + 1)) - 1)) == 0) {
    h++;
  }
  assert(total % (1 << h) == 0);

  struct MemoryChunk* chunk = &s_heap->small[h];

  // check size of bin, falling back to slow path
  if (chunk->next_cap < total) {
    return milone_mem_alloc_slow(h, chunk, total);
  }

  // use chunk
  void* ptr = chunk->next_ptr;
  chunk->next_ptr = (char*)ptr + total;
  chunk->next_cap -= total;
  s_heap_size += total;

  // fprintf(stderr, "debug: alloc level=%d size=%d (%dx%d) h=%d\n", s_heap_level, (int)((size_t)count * size), (int)count, (int)size, h);
  return ptr;
}

int int_cmp(int l, int r) {
  if (l == r) return 0;
  if (l < r) return -1;
  return 1;
}

int int_clamp(int x, int l, int r) {
  if (x < l) return l;
  if (x > r) return r;
  return x;
}

int str_cmp(struct String left, struct String right) {
  int min_len = int_clamp(left.len, 0, right.len);
  return memcmp(left.str, right.str, min_len + 1);
}

/// Create a string from a slice of native C string.
struct String str_of_raw_parts(char const* p, int len) {
  if (len <= 0) {
    if (len < 0) {
      fprintf(stderr, "FATAL: Negative string length (%d).\n", len);
      abort();
    }

    return (struct String){.str = "", .len = 0};
  }

  char* str = (char*)milone_mem_alloc(len + 1, sizeof(char));
  memcpy(str, p, len * sizeof(char));
  str[len] = '\0';
  return (struct String){.str = str, .len = len};
}

struct String str_add(struct String left, struct String right) {
  if (left.len == 0 || right.len == 0) {
    return right.len == 0 ? left : right;
  }
  int len = left.len + right.len;
  char* str = (char*)milone_mem_alloc(len + 1, sizeof(char));
  memcpy(str, left.str, left.len);
  memcpy(str + left.len, right.str, right.len);
  assert(str[len] == '\0');
  return (struct String){.str = str, .len = len};
}

struct String str_get_slice(int l, int r, struct String s) {
  l = int_clamp(l, 0, s.len);
  r = int_clamp(r + 1, l, s.len);
  int len = r - l;
  char* str;
  if (r == s.len) {
    str = s.str + l;
  } else {
    str = (char*)milone_mem_alloc(len + 1, sizeof(char));
    memcpy(str, s.str + l, len);
  }
  assert(str[len] == '\0');
  return (struct String){.str = str, .len = len};
}

int str_to_int(struct String s) {
  return atoi(s.str);
}

struct String str_of_int(int value) {
  char* str = (char *)milone_mem_alloc(20, sizeof(char));
  sprintf(str, "%d", value);
  return (struct String){.str = str, .len = strlen(str)};
}

uint32_t str_to_uint(struct String s) {
  char* endptr = s.str + s.len;
  uint32_t n = strtoul(s.str, &endptr, 10);
  if ((*endptr != '\0' && !isspace(*endptr)) || errno == ERANGE) {
    fprintf(stderr, "FATAL: Failed to convert a string to uint.\n");
    abort();
  }
  return n;
}

struct String str_of_uint(uint32_t value) {
  char buf[20] = {};
  int len = sprintf(buf, "%u", value);
  return str_of_raw_parts(buf, len);
}

struct String str_of_char(char value) {
  char* str = (char *)milone_mem_alloc(2, sizeof(char));
  str[0] = value;
  return (struct String){.str = str, .len = strlen(str)};
}

void milone_assert(int cond, int y, int x) {
  if (!cond) {
    fprintf(stderr, "Assertion failed at (%d, %d)\n", y + 1, x + 1);
    exit(1);
  }
}

int file_exists(struct String file_name) {
  int ok = 0;

  FILE *fp = fopen(file_name.str, "r");
  if (fp) {
    ok = 1;
    fclose(fp);
  }

  return ok;
}

struct String file_read_all_text(struct String file_name) {
  FILE *fp = fopen(file_name.str, "r");
  if (!fp) {
    fprintf(stderr, "File '%s' not found.", file_name.str);
    abort();
  }

  fseek(fp, 0, SEEK_END);
  long size = ftell(fp);
  if (size < 0) {
    fclose(fp);
    fprintf(stderr, "%s", "Couldn't retrieve the file size.");
    abort();
  }
  fseek(fp, 0, SEEK_SET);

  char *content = (char *)milone_mem_alloc((size_t)size + 1, sizeof(char));
  size_t read_size = fread(content, 1, (size_t)size, fp);
  if (read_size != (size_t)size) {
    fclose(fp);
    fprintf(stderr, "%s", "Couldn't retrieve the file contents");
    abort();
  }

  fclose(fp);
  return (struct String){.str = content, .len = size};
}

int file_write_all_text(struct String file_name, struct String content) {
  FILE *fp = fopen(file_name.str, "w");
  if (!fp) {
    fprintf(stderr, "File '%s' not found.", file_name.str);
    abort();
  }

  fprintf(fp, "%s", content.str);

  fclose(fp);
  return 0;
}

struct String milone_get_env(struct String name) {
  char const* value = getenv(name.str);
  if (value == NULL) {
    return (struct String){.str = "", .len = 0};
  }

  return str_of_raw_parts(value, strlen(value));
}

long milone_get_time_millis() {
  struct timespec t;
  timespec_get(&t, TIME_UTC);
  return t.tv_sec * 1000L + t.tv_nsec / (1000L * 1000L);
}

struct Profiler {
  long epoch;
  long heap_size;
};

void *milone_profile_init(int _unit) {
  struct Profiler* p = (struct Profiler *)milone_mem_alloc(1, sizeof(struct Profiler));
  p->epoch = milone_get_time_millis();
  p->heap_size = s_heap_size;
  return p;
}

int milone_profile_log(struct String msg, void *profiler) {
  struct Profiler *p = (struct Profiler *)profiler;

  long t = milone_get_time_millis();
  long s = p->epoch;

  long millis = t - s;
  if (millis < 0) {
    millis = 0;
  }

  long sec = millis / 1000;
  millis %= 1000;

  long bytes = s_heap_size - p->heap_size;
  if (bytes < 0) {
    bytes = 0;
  }

  long kilo = bytes / 1000;
  bytes %= 1000;

  long mega = kilo / 1000;
  kilo %= 1000;

  double usage = s_heap_alloc == 0 ? 0.0 : (double)s_heap_size / s_heap_alloc;
  fprintf(stderr, "profile: time=%4d.%03d mem=%5d,%03d,%03d use=%.03f\n%s\n", (int)sec, (int)millis, (int)mega, (int)kilo, (int)bytes, usage, msg.str);

  p->epoch = t;
  p->heap_size = s_heap_size;
  return 0; // can't be void due to restriction of __nativeFun
}

// -----------------------------------------------
// For competitive programming
// -----------------------------------------------

int scan_int(int _dummy) {
  int value;
  int _n = scanf("%d", &value);
  return value;
}

char scan_char(int _dummy) {
  char value;
  int _n = scanf("%c", &value);
  return value;
}

struct String scan_str(int capacity) {
  if (capacity <= 0) {
    fprintf(stderr, "scan_str(%d)", capacity);
    exit(1);
  }

  char *str = calloc(capacity, sizeof(char));
  if (str == NULL) {
    fprintf(stderr, "scan_str(%d) out of memory", capacity);
    exit(1);
  }

  char fmt[16] = {};
  sprintf(fmt, "%%%ds", capacity);
  assert(fmt[15] == 0);

  int _n = scanf(fmt, str);

  int len = strlen(str);
  assert(len < capacity);
  return (struct String){.str = str, .len = len};
}

int print_int(int value) {
  return printf("%d", value);
}

int print_char(char c) {
  return printf("%c", c);
}

int print_str(struct String str) {
  return printf("%s", str.str);
}

void *int_array_new(int len) {
  void *p = calloc(len, sizeof(int));
  // fprintf(stderr, "int_array_new(len=%d) = %p\n", len, p);
  return p;
}

int int_array_get(void *array, int index) {
  int value = ((int *)array)[index];
  // fprintf(stderr, "int_array_get(%p, index=%d) = %d\n", array, index, value);
  return value;
}

void *int_array_set(void *array, int index, int value) {
  // fprintf(stderr, "int_array_set(%p, index=%d, value=%d)\n", array, index, value);
  ((int *)array)[index] = value;
  return array;
}

// -----------------------------------------------
// Command-line Arguments
// -----------------------------------------------

static int s_argc;
static char **s_argv;

int arg_count(int _unit) {
  return s_argc;
}

struct String arg_get(int index) {
  if (!(0 <= index && index < s_argc)) {
    abort();
  }

  char *str = s_argv[index];
  int len = strlen(str);
  return (struct String){.str = str, .len = len};
}

// -----------------------------------------------
// Runtime Entrypoint
// -----------------------------------------------

int main(int argc, char** argv) {
  s_argc = argc - 1;
  s_argv = argv + 1;

  milone_enter_region();

  int milone_main();
  return milone_main();
}

#define main milone_main
